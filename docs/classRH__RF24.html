<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioHead: RH_RF24 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RadioHead
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classRH__RF24-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RH_RF24 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver to send and receive unaddressed, unreliable datagrams via an RF24 and compatible radio transceiver.  
 <a href="classRH__RF24.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RH__RF24_8h_source.html">RH_RF24.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RH_RF24:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRH__RF24.png" usemap="#RH_5FRF24_map" alt=""/>
  <map id="RH_5FRF24_map" name="RH_5FRF24_map">
<area href="classRHSPIDriver.html" title="Base class for RadioHead drivers that use the SPI bus to communicate with its transport hardware." alt="RHSPIDriver" shape="rect" coords="0,56,110,80"/>
<area href="classRHGenericDriver.html" title="Abstract base class for a RadioHead driver." alt="RHGenericDriver" shape="rect" coords="0,0,110,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRH__RF24_1_1CommandInfo.html">CommandInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the commands we can interrogate in printRegisters.  <a href="structRH__RF24_1_1CommandInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRH__RF24_1_1ModemConfig.html">ModemConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines property values for a set of modem configuration registers.  <a href="structRH__RF24_1_1ModemConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a186a59163ea9e246ccd3c0d9895f1849"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849">ModemConfigChoice</a> { <br />
&#160;&#160;<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849a0117defc6f5d5ffc496c2936e3d20a00">FSK_Rb0_5Fd1</a> = 0, 
<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849ae2e32010afd50c3c0319d1753cbddfae">FSK_Rb5Fd10</a>, 
<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849a79c90f018a05372a0515703bb8ec78f3">FSK_Rb50Fd100</a>, 
<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849a3729fa73c9c7f4ed8d4f0754a1b113b0">FSK_Rb150Fd300</a>, 
<br />
&#160;&#160;<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849afab82c503f7500fe3acf5e7e6576af9b">GFSK_Rb0_5Fd1</a>, 
<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849afb07888e57822a9b934fcec3563fec99">GFSK_Rb5Fd10</a>, 
<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849ab20f06478012c6a726dc9641794a0004">GFSK_Rb50Fd100</a>, 
<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849a4386af685d7c58260a485e90a4f3f32a">GFSK_Rb150Fd300</a>, 
<br />
&#160;&#160;<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849a5d3e644e9de33d25086833dbe207ef83">OOK_Rb5Bw30</a>, 
<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849ad1ab9542360b17619b098c6d262653af">OOK_Rb10Bw40</a>
<br />
 }</td></tr>
<tr class="separator:a186a59163ea9e246ccd3c0d9895f1849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9372266456896cd3552efe32c9353e6b"><td class="memItemLeft" align="right" valign="top"><a id="a9372266456896cd3552efe32c9353e6b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a9372266456896cd3552efe32c9353e6b">CRCPolynomial</a> { <br />
&#160;&#160;<b>CRC_NONE</b> = 0, 
<b>CRC_ITU_T</b>, 
<b>CRC_IEC_16</b>, 
<b>CRC_Biacheva</b>, 
<br />
&#160;&#160;<b>CRC_16_IBM</b>, 
<b>CRC_CCITT</b>, 
<b>CRC_Koopman</b>, 
<b>CRC_IEEE_802_3</b>, 
<br />
&#160;&#160;<b>CRC_Castagnoli</b>
<br />
 }</td></tr>
<tr class="memdesc:a9372266456896cd3552efe32c9353e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the available choices for CRC Types of permitted CRC polynomials, to be passed to <a class="el" href="classRH__RF24.html#a4c5d2b6dce422f3d09c83327ef603363">setCRCPolynomial()</a> They deliberately have the same numeric values as the CRC_POLYNOMIAL field of PKT_CRC_CONFIG. <br /></td></tr>
<tr class="separator:a9372266456896cd3552efe32c9353e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classRHGenericDriver"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRHGenericDriver')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRHGenericDriver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a7c96558708f18937bc2fa7341f217937 inherit pub_types_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a> { <br />
&#160;&#160;<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937ad901fedd5b99db75c942023971632c43">RHModeInitialising</a> = 0, 
<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a39cb96e8e2d40d5a4137f99c9d98d01b">RHModeSleep</a>, 
<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a09daae373d8c5f63419be869c99f8d66">RHModeIdle</a>, 
<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a2f830e2667843de407766fe33500713c">RHModeTx</a>, 
<br />
&#160;&#160;<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a37e9e88e825d4ec7728c421e3a32e490">RHModeRx</a>, 
<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a36997733490b61f1997529c8cfeb4211">RHModeCad</a>
<br />
 }</td></tr>
<tr class="memdesc:a7c96558708f18937bc2fa7341f217937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines different operating modes for the transport hardware.  <a href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937">More...</a><br /></td></tr>
<tr class="separator:a7c96558708f18937bc2fa7341f217937 inherit pub_types_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab10bf946dbd236182fe495b9c9dfeb09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#ab10bf946dbd236182fe495b9c9dfeb09">RH_RF24</a> (uint8_t slaveSelectPin=SS, uint8_t interruptPin=2, uint8_t sdnPin=9, <a class="el" href="classRHGenericSPI.html">RHGenericSPI</a> &amp;spi=hardware_spi)</td></tr>
<tr class="separator:ab10bf946dbd236182fe495b9c9dfeb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb53e42f79e769497ae564a8d74230e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init</a> ()</td></tr>
<tr class="separator:a2cb53e42f79e769497ae564a8d74230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ccdf26e4ec5ac2d6fc6af15486b942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a43ccdf26e4ec5ac2d6fc6af15486b942">setIdleMode</a> (uint8_t idleMode)</td></tr>
<tr class="separator:a43ccdf26e4ec5ac2d6fc6af15486b942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede4988f5e9daef3b471615aae7ad720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#aede4988f5e9daef3b471615aae7ad720">setFrequency</a> (float centre, float afcPullInRange=0.05)</td></tr>
<tr class="separator:aede4988f5e9daef3b471615aae7ad720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd00202f768b4f0f893f2fbb9e650c7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#afd00202f768b4f0f893f2fbb9e650c7b">setModemRegisters</a> (const <a class="el" href="structRH__RF24_1_1ModemConfig.html">ModemConfig</a> *config)</td></tr>
<tr class="separator:afd00202f768b4f0f893f2fbb9e650c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f0012333f9881c111b7722632d25a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a75f0012333f9881c111b7722632d25a9">setModemConfig</a> (<a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849">ModemConfigChoice</a> index)</td></tr>
<tr class="separator:a75f0012333f9881c111b7722632d25a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad807aee44ebdc88869aca06ceefb6607"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#ad807aee44ebdc88869aca06ceefb6607">available</a> ()</td></tr>
<tr class="separator:ad807aee44ebdc88869aca06ceefb6607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9937ab8c31b887a2d47c9e7fd2c7370e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a9937ab8c31b887a2d47c9e7fd2c7370e">recv</a> (uint8_t *buf, uint8_t *len)</td></tr>
<tr class="separator:a9937ab8c31b887a2d47c9e7fd2c7370e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaa8c5b36eccb568c87c4c9e74e7877"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a9aaa8c5b36eccb568c87c4c9e74e7877">send</a> (const uint8_t *data, uint8_t len)</td></tr>
<tr class="separator:a9aaa8c5b36eccb568c87c4c9e74e7877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015e03fd103d893d2e92744c5e5bbc2d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a015e03fd103d893d2e92744c5e5bbc2d">maxMessageLength</a> ()</td></tr>
<tr class="separator:a015e03fd103d893d2e92744c5e5bbc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad362ade85bb04260ce35e8e1e0071a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#ad362ade85bb04260ce35e8e1e0071a56">setPreambleLength</a> (uint16_t bytes)</td></tr>
<tr class="separator:ad362ade85bb04260ce35e8e1e0071a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaa19e721fe511ac04b08e9e3a7e723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a9eaa19e721fe511ac04b08e9e3a7e723">setSyncWords</a> (const uint8_t *syncWords=NULL, uint8_t len=0)</td></tr>
<tr class="separator:a9eaa19e721fe511ac04b08e9e3a7e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5d2b6dce422f3d09c83327ef603363"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a4c5d2b6dce422f3d09c83327ef603363">setCRCPolynomial</a> (<a class="el" href="classRH__RF24.html#a9372266456896cd3552efe32c9353e6b">CRCPolynomial</a> polynomial)</td></tr>
<tr class="separator:a4c5d2b6dce422f3d09c83327ef603363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a848fae609a7a0c9f27c257763aaba9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a5a848fae609a7a0c9f27c257763aaba9">setModeIdle</a> ()</td></tr>
<tr class="separator:a5a848fae609a7a0c9f27c257763aaba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52218f0ec1c9c8ec01b6ca771309faf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a52218f0ec1c9c8ec01b6ca771309faf4">setModeRx</a> ()</td></tr>
<tr class="separator:a52218f0ec1c9c8ec01b6ca771309faf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85c8e01f3b660dc612ff81890169353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#ad85c8e01f3b660dc612ff81890169353">setModeTx</a> ()</td></tr>
<tr class="separator:ad85c8e01f3b660dc612ff81890169353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2078de5a7a5821a673fcf7ab95ab8575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a2078de5a7a5821a673fcf7ab95ab8575">setTxPower</a> (uint8_t power)</td></tr>
<tr class="separator:a2078de5a7a5821a673fcf7ab95ab8575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6affeab37006d27081f76aac6a0d4344"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a6affeab37006d27081f76aac6a0d4344">printRegisters</a> ()</td></tr>
<tr class="separator:a6affeab37006d27081f76aac6a0d4344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a2b39cc3a6350addb97327b6f8af33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command</a> (uint8_t cmd, const uint8_t *write_buf=0, uint8_t write_len=0, uint8_t *read_buf=0, uint8_t read_len=0)</td></tr>
<tr class="separator:ab5a2b39cc3a6350addb97327b6f8af33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a67573e1fc7156307720d1471b979"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a962a67573e1fc7156307720d1471b979">set_properties</a> (uint16_t firstProperty, const uint8_t *values, uint8_t count)</td></tr>
<tr class="separator:a962a67573e1fc7156307720d1471b979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd69cb68333664481c650c8ebd11d9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a4dd69cb68333664481c650c8ebd11d9b">get_properties</a> (uint16_t firstProperty, uint8_t *values, uint8_t count)</td></tr>
<tr class="separator:a4dd69cb68333664481c650c8ebd11d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3092e0f3a196980569c3e021a4a13921"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a3092e0f3a196980569c3e021a4a13921">get_temperature</a> ()</td></tr>
<tr class="separator:a3092e0f3a196980569c3e021a4a13921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d3d16017d5a35a8ae3367e82e77117"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#af6d3d16017d5a35a8ae3367e82e77117">get_battery_voltage</a> ()</td></tr>
<tr class="separator:af6d3d16017d5a35a8ae3367e82e77117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a82045628623c6bd1e01f0a70dc0da"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a78a82045628623c6bd1e01f0a70dc0da">get_gpio_voltage</a> (uint8_t gpio)</td></tr>
<tr class="separator:a78a82045628623c6bd1e01f0a70dc0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73bf30c17449b94e2e1c73e758f6518"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#aa73bf30c17449b94e2e1c73e758f6518">frr_read</a> (uint8_t reg)</td></tr>
<tr class="separator:aa73bf30c17449b94e2e1c73e758f6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09177ddfb09bf6ca41b94503cbee9fb7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a09177ddfb09bf6ca41b94503cbee9fb7">sleep</a> ()</td></tr>
<tr class="separator:a09177ddfb09bf6ca41b94503cbee9fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa368cbdfd7709d4ea372c6c5bf414751"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#aa368cbdfd7709d4ea372c6c5bf414751">deviceType</a> ()</td></tr>
<tr class="separator:aa368cbdfd7709d4ea372c6c5bf414751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRHSPIDriver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRHSPIDriver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRHSPIDriver.html">RHSPIDriver</a></td></tr>
<tr class="memitem:a4285d2fb96b09588556bfc4f8a143f61 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a4285d2fb96b09588556bfc4f8a143f61">RHSPIDriver</a> (uint8_t slaveSelectPin=SS, <a class="el" href="classRHGenericSPI.html">RHGenericSPI</a> &amp;spi=hardware_spi)</td></tr>
<tr class="separator:a4285d2fb96b09588556bfc4f8a143f61 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba5e6fc53e02ff8125218bc296b4557 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a7ba5e6fc53e02ff8125218bc296b4557">init</a> ()</td></tr>
<tr class="separator:a7ba5e6fc53e02ff8125218bc296b4557 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275b8c3d4d27a59d8f93a036b17bbf22 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a275b8c3d4d27a59d8f93a036b17bbf22">spiRead</a> (uint8_t reg)</td></tr>
<tr class="separator:a275b8c3d4d27a59d8f93a036b17bbf22 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649210bd63262e23c9becabfc7142fd3 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">spiWrite</a> (uint8_t reg, uint8_t val)</td></tr>
<tr class="separator:a649210bd63262e23c9becabfc7142fd3 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ffebc1db1a6008734a37c4448fe926 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#af0ffebc1db1a6008734a37c4448fe926">spiBurstRead</a> (uint8_t reg, uint8_t *dest, uint8_t len)</td></tr>
<tr class="separator:af0ffebc1db1a6008734a37c4448fe926 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559b2c489825fe1ae737cb4371956d3d inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a559b2c489825fe1ae737cb4371956d3d">spiBurstWrite</a> (uint8_t reg, const uint8_t *src, uint8_t len)</td></tr>
<tr class="separator:a559b2c489825fe1ae737cb4371956d3d inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cc3ee4a7cceb8b283e2efc3f2a6362 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a89cc3ee4a7cceb8b283e2efc3f2a6362">setSlaveSelectPin</a> (uint8_t slaveSelectPin)</td></tr>
<tr class="separator:a89cc3ee4a7cceb8b283e2efc3f2a6362 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b2a8e0b99bec6997aff996d644b554 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a21b2a8e0b99bec6997aff996d644b554">spiUsingInterrupt</a> (uint8_t interruptNumber)</td></tr>
<tr class="separator:a21b2a8e0b99bec6997aff996d644b554 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRHGenericDriver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRHGenericDriver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRHGenericDriver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="aacf1b301be4cc16800a62632df6fdd37"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#aacf1b301be4cc16800a62632df6fdd37">RHGenericDriver</a> ()</td></tr>
<tr class="memdesc:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf108e52389353cb3658b6802b92c77c inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#abf108e52389353cb3658b6802b92c77c">waitAvailable</a> ()</td></tr>
<tr class="separator:abf108e52389353cb3658b6802b92c77c inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7506f47e9a391ffa05f7271950c26ffe inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a7506f47e9a391ffa05f7271950c26ffe">waitPacketSent</a> ()</td></tr>
<tr class="separator:a7506f47e9a391ffa05f7271950c26ffe inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feda1f5522522dc50e0c26dcdef71dd inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a0feda1f5522522dc50e0c26dcdef71dd">waitPacketSent</a> (uint16_t timeout)</td></tr>
<tr class="separator:a0feda1f5522522dc50e0c26dcdef71dd inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed545cecc22196a325333dc9637e4cf inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a8ed545cecc22196a325333dc9637e4cf">waitAvailableTimeout</a> (uint16_t timeout)</td></tr>
<tr class="separator:a8ed545cecc22196a325333dc9637e4cf inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac577b932ba8b042b8170b24d513635c7 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#ac577b932ba8b042b8170b24d513635c7">waitCAD</a> ()</td></tr>
<tr class="separator:ac577b932ba8b042b8170b24d513635c7 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445039899f159c02bf6e642e3e12d9b9 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a445039899f159c02bf6e642e3e12d9b9">setCADTimeout</a> (unsigned long cad_timeout)</td></tr>
<tr class="separator:a445039899f159c02bf6e642e3e12d9b9 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bc85a58ebc777ea1f3b57f3ae87b1b inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#af4bc85a58ebc777ea1f3b57f3ae87b1b">isChannelActive</a> ()</td></tr>
<tr class="separator:af4bc85a58ebc777ea1f3b57f3ae87b1b inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f15e1e7480899d18c3a21248bb628 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a5e8f15e1e7480899d18c3a21248bb628">setThisAddress</a> (uint8_t thisAddress)</td></tr>
<tr class="separator:a5e8f15e1e7480899d18c3a21248bb628 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182436232f7a345bca0d1766d242f3fb inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a182436232f7a345bca0d1766d242f3fb">setHeaderTo</a> (uint8_t to)</td></tr>
<tr class="separator:a182436232f7a345bca0d1766d242f3fb inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e67f4168dec41435dcc0e194202c8 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a470e67f4168dec41435dcc0e194202c8">setHeaderFrom</a> (uint8_t from)</td></tr>
<tr class="separator:a470e67f4168dec41435dcc0e194202c8 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd57079264bda98bc89145fe5d2eb8f inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a4dd57079264bda98bc89145fe5d2eb8f">setHeaderId</a> (uint8_t id)</td></tr>
<tr class="separator:a4dd57079264bda98bc89145fe5d2eb8f inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb992b3c5e360e68b67e4843558bcf3b inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#acb992b3c5e360e68b67e4843558bcf3b">setHeaderFlags</a> (uint8_t set, uint8_t clear=RH_FLAGS_APPLICATION_SPECIFIC)</td></tr>
<tr class="separator:acb992b3c5e360e68b67e4843558bcf3b inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2791f57538b02a73e7dbe1031048230e inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a2791f57538b02a73e7dbe1031048230e">setPromiscuous</a> (bool promiscuous)</td></tr>
<tr class="separator:a2791f57538b02a73e7dbe1031048230e inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f49c9fe68354b50988dec435fa8d086 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a6f49c9fe68354b50988dec435fa8d086">headerTo</a> ()</td></tr>
<tr class="separator:a6f49c9fe68354b50988dec435fa8d086 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf7a972186592c51c6fde034d17ab9f inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a8cf7a972186592c51c6fde034d17ab9f">headerFrom</a> ()</td></tr>
<tr class="separator:a8cf7a972186592c51c6fde034d17ab9f inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81548960bb29a3ac35325c74cd562f45 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a81548960bb29a3ac35325c74cd562f45">headerId</a> ()</td></tr>
<tr class="separator:a81548960bb29a3ac35325c74cd562f45 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056fbd2df558971fe8a1653499a37c63 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a056fbd2df558971fe8a1653499a37c63">headerFlags</a> ()</td></tr>
<tr class="separator:a056fbd2df558971fe8a1653499a37c63 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e349acc48e935bf30111d388458e7b inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#aa3e349acc48e935bf30111d388458e7b">lastRssi</a> ()</td></tr>
<tr class="separator:aa3e349acc48e935bf30111d388458e7b inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff7dfded27279332cf8fa6f15dce74 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a80ff7dfded27279332cf8fa6f15dce74">mode</a> ()</td></tr>
<tr class="separator:a80ff7dfded27279332cf8fa6f15dce74 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="aa1c0a94ba6414b5bbab0133c4d74e646"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#aa1c0a94ba6414b5bbab0133c4d74e646">setMode</a> (<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a> <a class="el" href="classRHGenericDriver.html#a80ff7dfded27279332cf8fa6f15dce74">mode</a>)</td></tr>
<tr class="memdesc:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the operating mode of the transport. <br /></td></tr>
<tr class="separator:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0163fb71dc8d0cd86136882886adba7f inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a0163fb71dc8d0cd86136882886adba7f">rxBad</a> ()</td></tr>
<tr class="separator:a0163fb71dc8d0cd86136882886adba7f inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f730e644ab1f5f529fdfa82fdb2ed69 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a5f730e644ab1f5f529fdfa82fdb2ed69">rxGood</a> ()</td></tr>
<tr class="separator:a5f730e644ab1f5f529fdfa82fdb2ed69 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a408f88a1188a0fab458816cb705f4 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a66a408f88a1188a0fab458816cb705f4">txGood</a> ()</td></tr>
<tr class="separator:a66a408f88a1188a0fab458816cb705f4 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ace446bd70542adeedf7f7403212e809c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#ace446bd70542adeedf7f7403212e809c">handleInterrupt</a> ()</td></tr>
<tr class="separator:ace446bd70542adeedf7f7403212e809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094aa6d7c2dde3bd1ed33dfa15639014"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a094aa6d7c2dde3bd1ed33dfa15639014">clearRxFifo</a> ()</td></tr>
<tr class="separator:a094aa6d7c2dde3bd1ed33dfa15639014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c64a058c663d9aaeddb72740466e7b"><td class="memItemLeft" align="right" valign="top"><a id="a87c64a058c663d9aaeddb72740466e7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a87c64a058c663d9aaeddb72740466e7b">clearBuffer</a> ()</td></tr>
<tr class="memdesc:a87c64a058c663d9aaeddb72740466e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears <a class="el" href="classRH__RF24.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF24 and compatible radio transce...">RH_RF24</a>'s internal TX and RX buffers and counters. <br /></td></tr>
<tr class="separator:a87c64a058c663d9aaeddb72740466e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d9f5aa2574d6a551d4e2aea956353a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a24d9f5aa2574d6a551d4e2aea956353a">sendNextFragment</a> ()</td></tr>
<tr class="separator:a24d9f5aa2574d6a551d4e2aea956353a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d30de3f323b945c61feac26b614a89a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a7d30de3f323b945c61feac26b614a89a">readNextFragment</a> ()</td></tr>
<tr class="separator:a7d30de3f323b945c61feac26b614a89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd54aecdd3cff38aca2a912c200e3fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#afd54aecdd3cff38aca2a912c200e3fe7">writeTxFifo</a> (uint8_t *data, uint8_t len)</td></tr>
<tr class="separator:afd54aecdd3cff38aca2a912c200e3fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183d6f3dabcf5a1e8a63ba5802621d87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a183d6f3dabcf5a1e8a63ba5802621d87">validateRxBuf</a> ()</td></tr>
<tr class="separator:a183d6f3dabcf5a1e8a63ba5802621d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471d6cc5c9ca51468e137896292acdaf"><td class="memItemLeft" align="right" valign="top"><a id="a471d6cc5c9ca51468e137896292acdaf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a471d6cc5c9ca51468e137896292acdaf">power_on_reset</a> ()</td></tr>
<tr class="memdesc:a471d6cc5c9ca51468e137896292acdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycles the Shutdown pin to force the cradio chip to reset. <br /></td></tr>
<tr class="separator:a471d6cc5c9ca51468e137896292acdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be39ccf8c3ea956e962b0edf3e51310"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#a6be39ccf8c3ea956e962b0edf3e51310">configure</a> (const uint8_t *commands)</td></tr>
<tr class="separator:a6be39ccf8c3ea956e962b0edf3e51310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65c55eb42b2a284a14aca8dd0ffa849"><td class="memItemLeft" align="right" valign="top"><a id="aa65c55eb42b2a284a14aca8dd0ffa849"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF24.html#aa65c55eb42b2a284a14aca8dd0ffa849">cmd_clear_all_interrupts</a> ()</td></tr>
<tr class="memdesc:aa65c55eb42b2a284a14aca8dd0ffa849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all pending interrutps in the radio chip. <br /></td></tr>
<tr class="separator:aa65c55eb42b2a284a14aca8dd0ffa849"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classRHGenericDriver"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classRHGenericDriver')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classRHGenericDriver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a63915f6420833eb8ec61ee3b0610e34b inherit pub_static_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a63915f6420833eb8ec61ee3b0610e34b">printBuffer</a> (const char *prompt, const uint8_t *buf, uint8_t len)</td></tr>
<tr class="separator:a63915f6420833eb8ec61ee3b0610e34b inherit pub_static_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classRHSPIDriver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRHSPIDriver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRHSPIDriver.html">RHSPIDriver</a></td></tr>
<tr class="memitem:ad9ee8d997815ec209d3208967107ffb1 inherit pro_attribs_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top"><a id="ad9ee8d997815ec209d3208967107ffb1"></a>
<a class="el" href="classRHGenericSPI.html">RHGenericSPI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#ad9ee8d997815ec209d3208967107ffb1">_spi</a></td></tr>
<tr class="memdesc:ad9ee8d997815ec209d3208967107ffb1 inherit pro_attribs_classRHSPIDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the <a class="el" href="classRHGenericSPI.html" title="Base class for SPI interfaces.">RHGenericSPI</a> instance to use to transfer data with the SPI device. <br /></td></tr>
<tr class="separator:ad9ee8d997815ec209d3208967107ffb1 inherit pro_attribs_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63525878860cc6ab6c4a994ce704735 inherit pro_attribs_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top"><a id="ab63525878860cc6ab6c4a994ce704735"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#ab63525878860cc6ab6c4a994ce704735">_slaveSelectPin</a></td></tr>
<tr class="memdesc:ab63525878860cc6ab6c4a994ce704735 inherit pro_attribs_classRHSPIDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pin number of the Slave Select pin that is used to select the desired device. <br /></td></tr>
<tr class="separator:ab63525878860cc6ab6c4a994ce704735 inherit pro_attribs_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classRHGenericDriver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRHGenericDriver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRHGenericDriver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a324854a5f898b0a48ec83424351730c5"></a>
volatile <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">_mode</a></td></tr>
<tr class="memdesc:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current transport operating mode. <br /></td></tr>
<tr class="separator:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a6d2e9824e29c9d5e9ad28682e53ea974"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a6d2e9824e29c9d5e9ad28682e53ea974">_thisAddress</a></td></tr>
<tr class="memdesc:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node id. <br /></td></tr>
<tr class="separator:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a2d94c93203714ed3dd9a7434101683e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a2d94c93203714ed3dd9a7434101683e9">_promiscuous</a></td></tr>
<tr class="memdesc:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transport is in promiscuous mode. <br /></td></tr>
<tr class="separator:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="abff3740bc072a2d435194a7860b2bfe3"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#abff3740bc072a2d435194a7860b2bfe3">_rxHeaderTo</a></td></tr>
<tr class="memdesc:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">TO header in the last received mesasge. <br /></td></tr>
<tr class="separator:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a7283cfec4e7c1ecf074307534592fd8f"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a7283cfec4e7c1ecf074307534592fd8f">_rxHeaderFrom</a></td></tr>
<tr class="memdesc:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FROM header in the last received mesasge. <br /></td></tr>
<tr class="separator:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a3155557c35198acdde0ecdf58a201b19"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a3155557c35198acdde0ecdf58a201b19">_rxHeaderId</a></td></tr>
<tr class="memdesc:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID header in the last received mesasge. <br /></td></tr>
<tr class="separator:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a5fd0c3bbc3cfe199924a9e1cb909f5fd"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a5fd0c3bbc3cfe199924a9e1cb909f5fd">_rxHeaderFlags</a></td></tr>
<tr class="memdesc:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLAGS header in the last received mesasge. <br /></td></tr>
<tr class="separator:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a759debcdbdb837cea024f777020203e5"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a759debcdbdb837cea024f777020203e5">_txHeaderTo</a></td></tr>
<tr class="memdesc:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">TO header to send in all messages. <br /></td></tr>
<tr class="separator:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a2c7cdccccf1b17c73ef95dca6d3075f9"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a2c7cdccccf1b17c73ef95dca6d3075f9">_txHeaderFrom</a></td></tr>
<tr class="memdesc:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FROM header to send in all messages. <br /></td></tr>
<tr class="separator:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="ad0eafb5a8316b90ad8cd9d42234517da"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#ad0eafb5a8316b90ad8cd9d42234517da">_txHeaderId</a></td></tr>
<tr class="memdesc:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID header to send in all messages. <br /></td></tr>
<tr class="separator:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="abf4db9bddfee361cc44fbf4bd22202bc"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#abf4db9bddfee361cc44fbf4bd22202bc">_txHeaderFlags</a></td></tr>
<tr class="memdesc:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLAGS header to send in all messages. <br /></td></tr>
<tr class="separator:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b67eea20e8f9a688d61a5a6b6b2be03 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a9b67eea20e8f9a688d61a5a6b6b2be03"></a>
volatile int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a9b67eea20e8f9a688d61a5a6b6b2be03">_lastRssi</a></td></tr>
<tr class="memdesc:a9b67eea20e8f9a688d61a5a6b6b2be03 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the last received RSSI value, in some transport specific units. <br /></td></tr>
<tr class="separator:a9b67eea20e8f9a688d61a5a6b6b2be03 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a3bafd8dc638309a473367c4ff8e59c0e"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a3bafd8dc638309a473367c4ff8e59c0e">_rxBad</a></td></tr>
<tr class="memdesc:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of bad messages (eg bad checksum etc) received. <br /></td></tr>
<tr class="separator:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="abf09ee8b0cc1bf2b64dc0d963895ff71"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#abf09ee8b0cc1bf2b64dc0d963895ff71">_rxGood</a></td></tr>
<tr class="memdesc:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of successfully transmitted messaged. <br /></td></tr>
<tr class="separator:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a5f71653ad58e35ddca7fe3e052674ca2"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a5f71653ad58e35ddca7fe3e052674ca2">_txGood</a></td></tr>
<tr class="memdesc:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of bad messages (correct checksum etc) received. <br /></td></tr>
<tr class="separator:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028f651c56df90b8b9d852e16ac3356e inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a028f651c56df90b8b9d852e16ac3356e"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a028f651c56df90b8b9d852e16ac3356e">_cad</a></td></tr>
<tr class="memdesc:a028f651c56df90b8b9d852e16ac3356e inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel activity detected. <br /></td></tr>
<tr class="separator:a028f651c56df90b8b9d852e16ac3356e inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e86bc833626b8255fbc43917932d0d6 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a id="a3e86bc833626b8255fbc43917932d0d6"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a3e86bc833626b8255fbc43917932d0d6">_cad_timeout</a></td></tr>
<tr class="memdesc:a3e86bc833626b8255fbc43917932d0d6 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel activity timeout in ms. <br /></td></tr>
<tr class="separator:a3e86bc833626b8255fbc43917932d0d6 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Driver to send and receive unaddressed, unreliable datagrams via an RF24 and compatible radio transceiver. </p>
<p>Works with</p><ul>
<li>Silicon Labs Si4460/1/2/3/4 transceiver chips</li>
<li>The equivalent HopeRF RF24/25/26/27 transceiver chips</li>
<li>HopeRF Complete modules: RFM24W/26W/27W</li>
</ul>
<dl class="section user"><dt>Overview</dt><dd></dd></dl>
<p>This class provides basic functions for sending and receiving unaddressed, unreliable datagrams of arbitrary length to 250 octets per packet.</p>
<p>Manager classes may use this class to implement reliable, addressed datagrams and streams, mesh routers, repeaters, translators etc.</p>
<p>Naturally, for any 2 radios to communicate that must be configured to use the same frequency and modulation scheme.</p>
<p>This Driver provides an object-oriented interface for sending and receiving data messages with Hope-RF RF24 and compatible radio modules, such as the RFM24W module.</p>
<p>The Hope-RF (<a href="http://www.hoperf.com">http://www.hoperf.com</a>) RF24 family is a low-cost ISM transceiver chip. It supports FSK, GFSK, OOK over a wide range of frequencies and programmable data rates. HopeRF also sell these chips on modules which includes a crystal and antenna coupling circuits: RFM24W, RFM26W and RFM27W</p>
<p>This Driver provides functions for sending and receiving messages of up to 250 octets on any frequency supported by the RF24, in a range of predefined data rates and frequency deviations. Frequency can be set to any frequency from 142.0MHz to 1050.0MHz. Caution: most modules only support a more limited range of frequencies due to antenna tuning.</p>
<p>Up to 2 RFM24 modules can be connected to an Arduino (3 on a Mega), permitting the construction of translators and frequency changers, etc.</p>
<p>The following modulation types are suppported with a range of modem configurations for common data rates and frequency deviations:</p><ul>
<li>OOK On-Off Keying</li>
<li>GFSK Gaussian Frequency Shift Keying</li>
<li>FSK Frequency Shift Keying</li>
</ul>
<p>Support for other RF24 features such as on-chip temperature measurement, transmitter power control etc is also provided.</p>
<p><a class="el" href="classRH__RF24.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF24 and compatible radio transce...">RH_RF24</a> uses interrupts to detect and handle events in the radio chip. The RF24 family has TX and RX FIFOs of 64 bytes, but through the use of interrupt, the <a class="el" href="classRH__RF24.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF24 and compatible radio transce...">RH_RF24</a> driver can send longer messages by filling or emptying the FIFOs on-the-fly.</p>
<p>Tested on Anarduino Mini <a href="http://www.anarduino.com/mini/">http://www.anarduino.com/mini/</a> with arduino-1.0.5 on OpenSuSE 13.1. Also on Anarduino Mini with arduino-1.8.1 on Kubuntu 16.04</p>
<dl class="section user"><dt>Packet Format</dt><dd></dd></dl>
<p>All messages sent and received by this <a class="el" href="classRH__RF24.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF24 and compatible radio transce...">RH_RF24</a> Driver conform to this packet format:</p>
<ul>
<li>4 octets PREAMBLE (configurable)</li>
<li>2 octets SYNC 0x2d, 0xd4 (configurable, so you can use this as a network filter)</li>
<li>Field containing 1 octet of message length and 2 octet CRC protecting this field</li>
<li>Field 2 containing at least 4 octets, and 2 octet CRC protecting this field:<ul>
<li>4 octets HEADER: (TO, FROM, ID, FLAGS)</li>
<li>0 to 250 octets DATA</li>
<li>2 octets CRC, computed on HEADER and DATA</li>
</ul>
</li>
</ul>
<dl class="section user"><dt>Connecting RFM-24 to Arduino</dt><dd></dd></dl>
<p>For RFM24/RFM26 and Teensy 3.1 or Anarduino Mini </p><div class="fragment"><div class="line">                Teensy      RFM-24/RFM26</div>
<div class="line">                GND----------GND (ground in)</div>
<div class="line">                3V3----------VCC   (3.3V in)</div>
<div class="line">interrupt 2 pin D2-----------NIRQ  (interrupt request out)</div>
<div class="line">         SS pin D10----------NSEL  (chip select in)</div>
<div class="line">        SCK pin D13----------SCK   (SPI clock in)</div>
<div class="line">       MOSI pin D11----------SDI   (SPI Data in)</div>
<div class="line">       MISO pin D12----------SDO   (SPI data out)</div>
<div class="line">                D9-----------SDN   (shutdown in)</div>
<div class="line">                          /--GPIO0 (GPIO0 out to control transmitter antenna TX_ANT)</div>
<div class="line">                          \--TX_ANT (TX antenna control in) RFM22B only</div>
<div class="line">                          /--GPIO1 (GPIO1 out to control receiver antenna RX_ANT)</div>
<div class="line">                          \--RX_ANT (RX antenna control in) RFM22B only</div>
</div><!-- fragment --><p> Caution: tying the radio SDN pin to ground (though it might appear from the data sheets to make sense) does not always produce a reliable radio startup. So this driver controls the SDN pin directly. Note: the GPIO0-TX_ANT and GPIO1-RX_ANT connections are not required for the 11dBm RFM24W, which has no antenna switch.</p>
<p>If you have an Arduino Zero, you should note that you cannot use Pin 2 for the interrupt line (Pin 2 is for the NMI only), instead you can use any other pin (we use Pin 3) and initialise <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> like this: </p><div class="fragment"><div class="line"><span class="comment">// Slave Select is pin 10, interrupt is Pin 3</span></div>
<div class="line"><a class="code" href="classRH__RF24.html">RH_RF24</a> driver(10, 3);</div>
</div><!-- fragment --><dl class="section user"><dt>Customising and configuring</dt><dd></dd></dl>
<p>The <a class="el" href="classRH__RF24.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF24 and compatible radio transce...">RH_RF24</a> module uses a radio configuration header file to configure the basic radio operation frequency and modulation scheme. The radio configuration header file must be generated with the Silicon Labs Wireless Development Suite (WDS) program and #included by RH_RF24.cpp</p>
<p>The library will work out of the box and without further configuring with these parameters:</p><ul>
<li>Si4464 or equvalent</li>
<li>30MHz Crytstal</li>
<li>434MHz base frequncy band</li>
<li>2GFSK modulation</li>
<li>5kbps data rate</li>
<li>10kHz deviation using the radio configuration header file RF24configs/radio_config_Si4464_30_434_2GFSK_5_10.h which is included in RadioHead.</li>
</ul>
<p>In order to use different frequency bands or modulation schemes, you must generate a new radio configuration header file with WDS, or select one of a small set of prebuilt headers from the RF24configs folder (see README in that folder for details of the filename format).</p>
<p>To generate a new header file:</p>
<ul>
<li>Install Silicon Labs Wireless Development Suite (WDS) 3.2.11.0 or later (Windows only, we were not able to get it to run under Wine on Linux)</li>
<li>Run WDS</li>
<li>Menu-&gt;Start Simulation</li>
<li>Select radio chip type Si4464, press Select Radio</li>
<li>Select Radio Configuration Application, press Select Application</li>
<li>Click on Standard Packet Tx</li>
<li>On the Frequency and Power tab, Select the Frequency, crystal frequency etc. The PA power level is irrelevant, since power is set programatically</li>
<li>On the RF parameters tab, select the modulation type and rates</li>
<li>Press Generate Source, Save custom radio configuration header file</li>
<li>Enter a new unique file name in the RF24configs folder in RadioHead</li>
<li>Edit RH_RF24.cpp to use this new header file</li>
<li>Recompile <a class="el" href="classRH__RF24.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF24 and compatible radio transce...">RH_RF24</a></li>
</ul>
<dl class="section user"><dt>RSSI</dt><dd></dd></dl>
<p>The RSSI (Received Signal Strength Indicator) is measured and latched after the message sync bytes are received. The latched RSSI is available from the <a class="el" href="classRHGenericDriver.html#aa3e349acc48e935bf30111d388458e7b">lastRssi()</a> member functionafter the complete message is received. Although <a class="el" href="classRHGenericDriver.html#aa3e349acc48e935bf30111d388458e7b">lastRssi()</a> supposedly returns a signed integer, in the case of this radio it actually returns an unsigned 8 bit integer (uint8_t) and you will have to cast the return value to use it: </p><div class="fragment"><div class="line">uint8_t <a class="code" href="classRHGenericDriver.html#aa3e349acc48e935bf30111d388458e7b">lastRssi</a> = (uint8_t)rf24.lastRssi();</div>
</div><!-- fragment --><p> The units of RSSI are arbitrary and relative, with larger unsigned numbers indicating a stronger signal. Values up to 255 are seen with radios in close proximity to each other. Lower limit of receivable strength is about 70.</p>
<dl class="section user"><dt>Transmitter Power</dt><dd></dd></dl>
<p>You can control the transmitter power on the RF24/25/26/27 transceiver with the <a class="el" href="classRH__RF24.html#a2078de5a7a5821a673fcf7ab95ab8575">RH_RF24::setTxPower()</a> function. The argument can be any of 0x00 to 0x4f (for RFM24/Si4460) or 0x00 to 0x7f (for others) 0x00 will yield no measurable power. For other settings there is a non-linear correlation with actual RF power output (see below) The default is 0x10. Eg: </p><div class="fragment"><div class="line">driver.<a class="code" href="classRH__RF22.html#ac60d2676f1177e509e7d31df515dfb11">setTxPower</a>(0x10);</div>
</div><!-- fragment --><p>We have made some actual power measurements against programmed power</p><ul>
<li>Anarduino Mini with RFM24-433 and RFM26-433 at Vcc = 3.3V, in CW mode, 434MHz</li>
<li>10cm RG58C/U soldered direct to RFM69 module ANT and GND</li>
<li>bnc connecteor</li>
<li>12dB attenuator</li>
<li>BNC-SMA adapter</li>
<li>MiniKits AD8307 HF/VHF Power Head (calibrated against Rohde&amp;Schwartz 806.2020 test set)</li>
<li>Digitech QM-1460 digital multimeter <div class="fragment"><div class="line">Program power           Measured Power dBm</div>
<div class="line">   HEX                  RFM24                RFM26</div>
<div class="line">   0x00                 not measurable       not measurable</div>
<div class="line">   0x01                 -20.4                -20.6</div>
<div class="line">   0x0f                 2.4                  4.8</div>
<div class="line">   0x1f                 9.4                  11.0</div>
<div class="line">   0x2f                 11.2                 14.2</div>
<div class="line">   0x3f                 11.6                 16.4</div>
<div class="line">   0x4f                 11.6                 18.0</div>
<div class="line">   0x5f                                      18.6</div>
<div class="line">   0x6f                                      19.0</div>
<div class="line">   0x7f                                      19.2</div>
</div><!-- fragment --> Caution: the actual radiated power output will depend heavily on the power supply voltage and the antenna. </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a186a59163ea9e246ccd3c0d9895f1849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186a59163ea9e246ccd3c0d9895f1849">&#9670;&nbsp;</a></span>ModemConfigChoice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849">RH_RF24::ModemConfigChoice</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choices for <a class="el" href="classRH__RF24.html#a75f0012333f9881c111b7722632d25a9">setModemConfig()</a> for a selected subset of common modulation types, and data rates. If you need another configuration, use the register calculator. and call <a class="el" href="classRH__RF24.html#afd00202f768b4f0f893f2fbb9e650c7b">setModemRegisters()</a> with your desired settings. <br  />
 These are indexes into MODEM_CONFIG_TABLE. We strongly recommend you use these symbolic definitions and not their integer equivalents: its possible that values will be changed in later versions (though we will try to avoid it). Contributions of new complete and tested ModemConfigs ready to add to this list will be readily accepted. OBSOLETE: no need ever to use this now </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a186a59163ea9e246ccd3c0d9895f1849a0117defc6f5d5ffc496c2936e3d20a00"></a>FSK_Rb0_5Fd1&#160;</td><td class="fielddoc"><p>FSK Rb = 0.5kbs, Fd = 1kHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="a186a59163ea9e246ccd3c0d9895f1849ae2e32010afd50c3c0319d1753cbddfae"></a>FSK_Rb5Fd10&#160;</td><td class="fielddoc"><p>FSK Rb = 5kbs, Fd = 10kHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="a186a59163ea9e246ccd3c0d9895f1849a79c90f018a05372a0515703bb8ec78f3"></a>FSK_Rb50Fd100&#160;</td><td class="fielddoc"><p>FSK Rb = 50kbs, Fd = 100kHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="a186a59163ea9e246ccd3c0d9895f1849a3729fa73c9c7f4ed8d4f0754a1b113b0"></a>FSK_Rb150Fd300&#160;</td><td class="fielddoc"><p>FSK Rb = 50kbs, Fd = 100kHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="a186a59163ea9e246ccd3c0d9895f1849afab82c503f7500fe3acf5e7e6576af9b"></a>GFSK_Rb0_5Fd1&#160;</td><td class="fielddoc"><p>GFSK Rb = 0.5kbs, Fd = 1kHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="a186a59163ea9e246ccd3c0d9895f1849afb07888e57822a9b934fcec3563fec99"></a>GFSK_Rb5Fd10&#160;</td><td class="fielddoc"><p>GFSK Rb = 5kbs, Fd = 10kHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="a186a59163ea9e246ccd3c0d9895f1849ab20f06478012c6a726dc9641794a0004"></a>GFSK_Rb50Fd100&#160;</td><td class="fielddoc"><p>GFSK Rb = 50kbs, Fd = 100kHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="a186a59163ea9e246ccd3c0d9895f1849a4386af685d7c58260a485e90a4f3f32a"></a>GFSK_Rb150Fd300&#160;</td><td class="fielddoc"><p>GFSK Rb = 150kbs, Fd = 300kHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="a186a59163ea9e246ccd3c0d9895f1849a5d3e644e9de33d25086833dbe207ef83"></a>OOK_Rb5Bw30&#160;</td><td class="fielddoc"><p>OOK Rb = 5kbs, Bw = 30kHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="a186a59163ea9e246ccd3c0d9895f1849ad1ab9542360b17619b098c6d262653af"></a>OOK_Rb10Bw40&#160;</td><td class="fielddoc"><p>OOK Rb = 10kbs, Bw = 40kHz. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab10bf946dbd236182fe495b9c9dfeb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10bf946dbd236182fe495b9c9dfeb09">&#9670;&nbsp;</a></span>RH_RF24()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RH_RF24::RH_RF24 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveSelectPin</em> = <code>SS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>interruptPin</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sdnPin</em> = <code>9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRHGenericSPI.html">RHGenericSPI</a> &amp;&#160;</td>
          <td class="paramname"><em>spi</em> = <code>hardware_spi</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. You can have multiple instances, but each instance must have its own interrupt and slave select pin. After constructing, you must call <a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init()</a> to initialise the interface and the radio module. A maximum of 3 instances can co-exist on one processor, provided there are sufficient distinct interrupt lines, one for each instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveSelectPin</td><td>the Arduino pin number of the output to use to select the RF24 before accessing it. Defaults to the normal SS pin for your Arduino (D10 for Diecimila, Uno etc, D53 for Mega, D10 for Maple) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptPin</td><td>The interrupt Pin number that is connected to the RF24 DIO0 interrupt line. Defaults to pin 2. Caution: You must specify an interrupt capable pin. On many Arduino boards, there are limitations as to which pins may be used as interrupts. On Leonardo pins 0, 1, 2 or 3. On Mega2560 pins 2, 3, 18, 19, 20, 21. On Due and Teensy, any digital pin. On other Arduinos pins 2 or 3. See <a href="http://arduino.cc/en/Reference/attachInterrupt">http://arduino.cc/en/Reference/attachInterrupt</a> for more details. On Chipkit Uno32, pins 38, 2, 7, 8, 35. On other boards, any digital pin may be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdnPin</td><td>The pin number connected to SDN on the radio. Defaults to pin 9. Connecting SDN directly to ground does not aloways provide reliable radio startup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the SPI interface object to use. Defaults to the standard Arduino hardware SPI interface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad807aee44ebdc88869aca06ceefb6607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad807aee44ebdc88869aca06ceefb6607">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts the receiver and checks whether a received message is available. This can be called multiple times in a timeout loop </p><dl class="section return"><dt>Returns</dt><dd>true if a complete, valid message has been received and is able to be retrieved by <a class="el" href="classRH__RF24.html#a9937ab8c31b887a2d47c9e7fd2c7370e">recv()</a> </dd></dl>

<p>Implements <a class="el" href="classRHGenericDriver.html#a2dd522b8eb16c51dc948b4ca4d623888">RHGenericDriver</a>.</p>

<p class="reference">References <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a2f830e2667843de407766fe33500713c">RHGenericDriver::RHModeTx</a>, and <a class="el" href="classRH__RF24.html#a52218f0ec1c9c8ec01b6ca771309faf4">setModeRx()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a9937ab8c31b887a2d47c9e7fd2c7370e">recv()</a>.</p>

</div>
</div>
<a id="a094aa6d7c2dde3bd1ed33dfa15639014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094aa6d7c2dde3bd1ed33dfa15639014">&#9670;&nbsp;</a></span>clearRxFifo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::clearRxFifo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the chips RX FIFO </p><dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#ace446bd70542adeedf7f7403212e809c">handleInterrupt()</a>, and <a class="el" href="classRH__RF24.html#a7d30de3f323b945c61feac26b614a89a">readNextFragment()</a>.</p>

</div>
</div>
<a id="ab5a2b39cc3a6350addb97327b6f8af33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a2b39cc3a6350addb97327b6f8af33">&#9670;&nbsp;</a></span>command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::command </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>write_buf</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>write_len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>read_buf</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>read_len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a string of command bytes to the chip and get a string of reply bytes Different RFM24 commands take different numbers of command bytes and send back different numbers of reply bytes. See the Si446x documentaiton for more details. Both command bytes and reply bytes are optional </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>The command number. One of RH_RF24_CMD_* </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_buf</td><td>Pointer to write_len bytes of command input bytes to send. If there are none, set to NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_len</td><td>The number of bytes to send from write_buf. If there are none, set to 0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">read_buf</td><td>Pointer to read_len bytes of storage where the reply stream from the comand will be written. If none are required, set to NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_len</td><td>The number of bytes to read from the reply stream. If none required, set to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the command succeeeded. </dd></dl>

<p class="reference">References <a class="el" href="classRHSPIDriver.html#ab63525878860cc6ab6c4a994ce704735">RHSPIDriver::_slaveSelectPin</a>, <a class="el" href="classRHSPIDriver.html#ad9ee8d997815ec209d3208967107ffb1">RHSPIDriver::_spi</a>, and <a class="el" href="classRHGenericSPI.html#a14bc6f8954d9d68c0a56319444ffdd24">RHGenericSPI::transfer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a094aa6d7c2dde3bd1ed33dfa15639014">clearRxFifo()</a>, <a class="el" href="classRH__RF24.html#aa65c55eb42b2a284a14aca8dd0ffa849">cmd_clear_all_interrupts()</a>, <a class="el" href="classRH__RF24.html#a6be39ccf8c3ea956e962b0edf3e51310">configure()</a>, <a class="el" href="classRH__RF24.html#af6d3d16017d5a35a8ae3367e82e77117">get_battery_voltage()</a>, <a class="el" href="classRH__RF24.html#a78a82045628623c6bd1e01f0a70dc0da">get_gpio_voltage()</a>, <a class="el" href="classRH__RF24.html#a4dd69cb68333664481c650c8ebd11d9b">get_properties()</a>, <a class="el" href="classRH__RF24.html#a3092e0f3a196980569c3e021a4a13921">get_temperature()</a>, <a class="el" href="classRH__RF24.html#ace446bd70542adeedf7f7403212e809c">handleInterrupt()</a>, <a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init()</a>, <a class="el" href="classRH__RF24.html#a6affeab37006d27081f76aac6a0d4344">printRegisters()</a>, <a class="el" href="classRH__RF24.html#a7d30de3f323b945c61feac26b614a89a">readNextFragment()</a>, <a class="el" href="classRH__RF24.html#a24d9f5aa2574d6a551d4e2aea956353a">sendNextFragment()</a>, <a class="el" href="classRH__RF24.html#a962a67573e1fc7156307720d1471b979">set_properties()</a>, <a class="el" href="classRH__RF24.html#a5a848fae609a7a0c9f27c257763aaba9">setModeIdle()</a>, <a class="el" href="classRH__RF24.html#a52218f0ec1c9c8ec01b6ca771309faf4">setModeRx()</a>, <a class="el" href="classRH__RF24.html#ad85c8e01f3b660dc612ff81890169353">setModeTx()</a>, and <a class="el" href="classRH__RF24.html#a09177ddfb09bf6ca41b94503cbee9fb7">sleep()</a>.</p>

</div>
</div>
<a id="a6be39ccf8c3ea956e962b0edf3e51310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be39ccf8c3ea956e962b0edf3e51310">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::configure </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>commands</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets registers, commands and properties in the ratio according to the data in the commands array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commands</td><td>Array of data containing radio commands in the format provided by radio_config_Si4460.h </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init()</a>.</p>

</div>
</div>
<a id="aa368cbdfd7709d4ea372c6c5bf414751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa368cbdfd7709d4ea372c6c5bf414751">&#9670;&nbsp;</a></span>deviceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t RH_RF24::deviceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the integer value of the device type as read from the device in from RH_RF24_CMD_PART_INFO. One of 0x4460, 0x4461, 0x4462 or 0x4463, depending on the type of device actually connected. </p><dl class="section return"><dt>Returns</dt><dd>The integer device type </dd></dl>

</div>
</div>
<a id="aa73bf30c17449b94e2e1c73e758f6518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73bf30c17449b94e2e1c73e758f6518">&#9670;&nbsp;</a></span>frr_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_RF24::frr_read </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read one of the Fast Read Response registers. The Fast Read Response register must be previously configured with the matching RH_RF24_PROPERTY_FRR_CTL_?_MODE property to select what chip property will be available in that register. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>The index of the FRR register to read. 0 means FRR A, 1 means B etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value read from the specified Fast Read Response register. </dd></dl>

<p class="reference">References <a class="el" href="classRHSPIDriver.html#ab63525878860cc6ab6c4a994ce704735">RHSPIDriver::_slaveSelectPin</a>, <a class="el" href="classRHSPIDriver.html#ad9ee8d997815ec209d3208967107ffb1">RHSPIDriver::_spi</a>, and <a class="el" href="classRHGenericSPI.html#a14bc6f8954d9d68c0a56319444ffdd24">RHGenericSPI::transfer()</a>.</p>

</div>
</div>
<a id="af6d3d16017d5a35a8ae3367e82e77117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d3d16017d5a35a8ae3367e82e77117">&#9670;&nbsp;</a></span>get_battery_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float RH_RF24::get_battery_voltage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Measures and returns the current Chip Vcc supply voltage. </p><dl class="section return"><dt>Returns</dt><dd>The current chip Vcc supply voltage in Volts. </dd></dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>.</p>

</div>
</div>
<a id="a78a82045628623c6bd1e01f0a70dc0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a82045628623c6bd1e01f0a70dc0da">&#9670;&nbsp;</a></span>get_gpio_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float RH_RF24::get_gpio_voltage </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Measures and returns the current voltage applied to a GPIO pin (which has previously been configured as a voltage input) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpio</td><td>The GPIO pin to read. 0 to 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current pin voltage in Volts. </dd></dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>.</p>

</div>
</div>
<a id="a4dd69cb68333664481c650c8ebd11d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd69cb68333664481c650c8ebd11d9b">&#9670;&nbsp;</a></span>get_properties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::get_properties </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>firstProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get one or more chip properties using the RH_RF24_CMD_GET_PROPERTY command. See the Si446x API Description AN625 for details on what properties are available. param[in] firstProperty The property number of the first property to get. The first value in the values array will be set with this property, and any subsequent values will be set from the following properties. One of RH_RF24_PROPERTY_* param[out] values Array of 0 or more values to receive the firstProperty and subsequent proerties param[in] count The number of values in the values array </p><dl class="section return"><dt>Returns</dt><dd>true if the command succeeeded. </dd></dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a6affeab37006d27081f76aac6a0d4344">printRegisters()</a>.</p>

</div>
</div>
<a id="a3092e0f3a196980569c3e021a4a13921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3092e0f3a196980569c3e021a4a13921">&#9670;&nbsp;</a></span>get_temperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float RH_RF24::get_temperature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Measures and returns the current Chip temperature. </p><dl class="section return"><dt>Returns</dt><dd>The current chip temperature in degrees Centigrade </dd></dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>.</p>

</div>
</div>
<a id="ace446bd70542adeedf7f7403212e809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace446bd70542adeedf7f7403212e809c">&#9670;&nbsp;</a></span>handleInterrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::handleInterrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a low level function to handle the interrupts for one instance of RF24. Called automatically by isr*() Should not need to be called by user code. </p>

<p class="reference">References <a class="el" href="classRHGenericDriver.html#a9b67eea20e8f9a688d61a5a6b6b2be03">RHGenericDriver::_lastRssi</a>, <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRHGenericDriver.html#a3bafd8dc638309a473367c4ff8e59c0e">RHGenericDriver::_rxBad</a>, <a class="el" href="classRHGenericDriver.html#a5f71653ad58e35ddca7fe3e052674ca2">RHGenericDriver::_txGood</a>, <a class="el" href="classRH__RF24.html#a87c64a058c663d9aaeddb72740466e7b">clearBuffer()</a>, <a class="el" href="classRH__RF24.html#a094aa6d7c2dde3bd1ed33dfa15639014">clearRxFifo()</a>, <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>, <a class="el" href="classRH__RF24.html#a7d30de3f323b945c61feac26b614a89a">readNextFragment()</a>, <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a09daae373d8c5f63419be869c99f8d66">RHGenericDriver::RHModeIdle</a>, <a class="el" href="classRH__RF24.html#a24d9f5aa2574d6a551d4e2aea956353a">sendNextFragment()</a>, and <a class="el" href="classRH__RF24.html#a183d6f3dabcf5a1e8a63ba5802621d87">validateRxBuf()</a>.</p>

</div>
</div>
<a id="a2cb53e42f79e769497ae564a8d74230e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb53e42f79e769497ae564a8d74230e">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialises this instance and the radio module connected to it. The following steps are taken:</p><ul>
<li>Initialise the slave select and shutdown pins and the SPI interface library</li>
<li>Checks the connected RF24 module can be communicated</li>
<li>Attaches an interrupt handler</li>
<li>Configures the RF24 module</li>
<li>Sets the frequency to 434.0 MHz</li>
<li>Sets the modem data rate to GFSK_Rb5Fd10</li>
<li>Sets the tranmitter power level to 16 (about 2.4dBm on RFM4) <dl class="section return"><dt>Returns</dt><dd>true if everything was successful </dd></dl>
</li>
</ul>

<p>Reimplemented from <a class="el" href="classRHGenericDriver.html#a3e1cfcd4d6187702c364cf4c81e76365">RHGenericDriver</a>.</p>

<p class="reference">References <a class="el" href="classRH__RF24.html#aa65c55eb42b2a284a14aca8dd0ffa849">cmd_clear_all_interrupts()</a>, <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>, <a class="el" href="classRH__RF24.html#a6be39ccf8c3ea956e962b0edf3e51310">configure()</a>, <a class="el" href="classRHSPIDriver.html#a7ba5e6fc53e02ff8125218bc296b4557">RHSPIDriver::init()</a>, <a class="el" href="classRH__RF24.html#a471d6cc5c9ca51468e137896292acdaf">power_on_reset()</a>, <a class="el" href="classRH__RF24.html#a962a67573e1fc7156307720d1471b979">set_properties()</a>, <a class="el" href="classRH__RF24.html#a4c5d2b6dce422f3d09c83327ef603363">setCRCPolynomial()</a>, <a class="el" href="classRH__RF24.html#ad362ade85bb04260ce35e8e1e0071a56">setPreambleLength()</a>, <a class="el" href="classRH__RF24.html#a9eaa19e721fe511ac04b08e9e3a7e723">setSyncWords()</a>, <a class="el" href="classRH__RF24.html#a2078de5a7a5821a673fcf7ab95ab8575">setTxPower()</a>, and <a class="el" href="classRHSPIDriver.html#a21b2a8e0b99bec6997aff996d644b554">RHSPIDriver::spiUsingInterrupt()</a>.</p>

</div>
</div>
<a id="a015e03fd103d893d2e92744c5e5bbc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015e03fd103d893d2e92744c5e5bbc2d">&#9670;&nbsp;</a></span>maxMessageLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_RF24::maxMessageLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum message length supported by this driver </p><dl class="section return"><dt>Returns</dt><dd>The maximum message length supported by this driver </dd></dl>

<p>Implements <a class="el" href="classRHGenericDriver.html#a267459de4eb3032c5efb8b220af7d164">RHGenericDriver</a>.</p>

</div>
</div>
<a id="a6affeab37006d27081f76aac6a0d4344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6affeab37006d27081f76aac6a0d4344">&#9670;&nbsp;</a></span>printRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::printRegisters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the values of available command replies and properties to the Serial device if RH_HAVE_SERIAL is defined for the current platform Not all commands have valid replies, therefore they are not all printed. Caution: the list is very long </p>

<p class="reference">References <a class="el" href="structRH__RF24_1_1CommandInfo.html#ae50cdc6f7e3dc69d65ed7b8ed1f4bf40">RH_RF24::CommandInfo::cmd</a>, <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>, <a class="el" href="classRH__RF24.html#a4dd69cb68333664481c650c8ebd11d9b">get_properties()</a>, and <a class="el" href="structRH__RF24_1_1CommandInfo.html#a28b7cb5af6d4e7500b055eb10c28edac">RH_RF24::CommandInfo::replyLen</a>.</p>

</div>
</div>
<a id="a7d30de3f323b945c61feac26b614a89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d30de3f323b945c61feac26b614a89a">&#9670;&nbsp;</a></span>readNextFragment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::readNextFragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the next part of the currenrtly received message from the chips RX FIFO to the receive buffer </p>

<p class="reference">References <a class="el" href="classRHGenericDriver.html#a3bafd8dc638309a473367c4ff8e59c0e">RHGenericDriver::_rxBad</a>, <a class="el" href="classRHSPIDriver.html#ab63525878860cc6ab6c4a994ce704735">RHSPIDriver::_slaveSelectPin</a>, <a class="el" href="classRHSPIDriver.html#ad9ee8d997815ec209d3208967107ffb1">RHSPIDriver::_spi</a>, <a class="el" href="classRH__RF24.html#a87c64a058c663d9aaeddb72740466e7b">clearBuffer()</a>, <a class="el" href="classRH__RF24.html#a094aa6d7c2dde3bd1ed33dfa15639014">clearRxFifo()</a>, <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>, <a class="el" href="classRH__RF24.html#a5a848fae609a7a0c9f27c257763aaba9">setModeIdle()</a>, and <a class="el" href="classRHGenericSPI.html#a14bc6f8954d9d68c0a56319444ffdd24">RHGenericSPI::transfer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#ace446bd70542adeedf7f7403212e809c">handleInterrupt()</a>.</p>

</div>
</div>
<a id="a9937ab8c31b887a2d47c9e7fd2c7370e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9937ab8c31b887a2d47c9e7fd2c7370e">&#9670;&nbsp;</a></span>recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::recv </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the receiver on if it not already on. If there is a valid message available, copy it to buf and return true else return false. If a message is copied, *len is set to the length (Caution, 0 length messages are permitted). You should be sure to call this function frequently enough to not miss any messages It is recommended that you call it in your main loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Location to copy the received message </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Pointer to available space in buf. Set to the actual number of octets copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a valid message was copied to buf </dd></dl>

<p>Implements <a class="el" href="classRHGenericDriver.html#a58f0f64dff770bbeb1b197a5fca0579a">RHGenericDriver</a>.</p>

<p class="reference">References <a class="el" href="classRH__RF24.html#ad807aee44ebdc88869aca06ceefb6607">available()</a>, and <a class="el" href="classRH__RF24.html#a87c64a058c663d9aaeddb72740466e7b">clearBuffer()</a>.</p>

</div>
</div>
<a id="a9aaa8c5b36eccb568c87c4c9e74e7877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aaa8c5b36eccb568c87c4c9e74e7877">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::send </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Waits until any previous transmit packet is finished being transmitted with <a class="el" href="classRHGenericDriver.html#a7506f47e9a391ffa05f7271950c26ffe">waitPacketSent()</a>. Then loads a message into the transmitter and starts the transmitter. Note that a message length of 0 is NOT permitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Array of data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes of data to send (&gt; 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message length was valid and it was correctly queued for transmit </dd></dl>

<p>Implements <a class="el" href="classRHGenericDriver.html#a5716069edea652af8019daaeb64357ee">RHGenericDriver</a>.</p>

<p class="reference">References <a class="el" href="classRHGenericDriver.html#abf4db9bddfee361cc44fbf4bd22202bc">RHGenericDriver::_txHeaderFlags</a>, <a class="el" href="classRHGenericDriver.html#a2c7cdccccf1b17c73ef95dca6d3075f9">RHGenericDriver::_txHeaderFrom</a>, <a class="el" href="classRHGenericDriver.html#ad0eafb5a8316b90ad8cd9d42234517da">RHGenericDriver::_txHeaderId</a>, <a class="el" href="classRHGenericDriver.html#a759debcdbdb837cea024f777020203e5">RHGenericDriver::_txHeaderTo</a>, <a class="el" href="classRH__RF24.html#a24d9f5aa2574d6a551d4e2aea956353a">sendNextFragment()</a>, <a class="el" href="classRH__RF24.html#a962a67573e1fc7156307720d1471b979">set_properties()</a>, <a class="el" href="classRH__RF24.html#a5a848fae609a7a0c9f27c257763aaba9">setModeIdle()</a>, <a class="el" href="classRH__RF24.html#ad85c8e01f3b660dc612ff81890169353">setModeTx()</a>, <a class="el" href="classRHGenericDriver.html#ac577b932ba8b042b8170b24d513635c7">RHGenericDriver::waitCAD()</a>, and <a class="el" href="classRHGenericDriver.html#a7506f47e9a391ffa05f7271950c26ffe">RHGenericDriver::waitPacketSent()</a>.</p>

</div>
</div>
<a id="a24d9f5aa2574d6a551d4e2aea956353a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d9f5aa2574d6a551d4e2aea956353a">&#9670;&nbsp;</a></span>sendNextFragment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::sendNextFragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the next part of the currently transmitting message into the chips TX buffer </p>

<p class="reference">References <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>, and <a class="el" href="classRH__RF24.html#afd54aecdd3cff38aca2a912c200e3fe7">writeTxFifo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#ace446bd70542adeedf7f7403212e809c">handleInterrupt()</a>, and <a class="el" href="classRH__RF24.html#a9aaa8c5b36eccb568c87c4c9e74e7877">send()</a>.</p>

</div>
</div>
<a id="a962a67573e1fc7156307720d1471b979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962a67573e1fc7156307720d1471b979">&#9670;&nbsp;</a></span>set_properties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::set_properties </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>firstProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set one or more chip properties using the RH_RF24_CMD_SET_PROPERTY command. See the Si446x API Description AN625 for details on what properties are available. param[in] firstProperty The property number of the first property to set. The first value in the values array will be used to set this property, and any subsequent values will be used to set the following properties. One of RH_RF24_PROPERTY_* param[in] values Array of 0 or more values to write the firstProperty and subsequent proerties param[in] count The number of values in the values array </p><dl class="section return"><dt>Returns</dt><dd>true if the command succeeeded. </dd></dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init()</a>, <a class="el" href="classRH__RF24.html#a9aaa8c5b36eccb568c87c4c9e74e7877">send()</a>, <a class="el" href="classRH__RF24.html#a4c5d2b6dce422f3d09c83327ef603363">setCRCPolynomial()</a>, <a class="el" href="classRH__RF24.html#aede4988f5e9daef3b471615aae7ad720">setFrequency()</a>, <a class="el" href="classRH__RF24.html#a52218f0ec1c9c8ec01b6ca771309faf4">setModeRx()</a>, <a class="el" href="classRH__RF24.html#ad362ade85bb04260ce35e8e1e0071a56">setPreambleLength()</a>, <a class="el" href="classRH__RF24.html#a9eaa19e721fe511ac04b08e9e3a7e723">setSyncWords()</a>, and <a class="el" href="classRH__RF24.html#a2078de5a7a5821a673fcf7ab95ab8575">setTxPower()</a>.</p>

</div>
</div>
<a id="a4c5d2b6dce422f3d09c83327ef603363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5d2b6dce422f3d09c83327ef603363">&#9670;&nbsp;</a></span>setCRCPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::setCRCPolynomial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRH__RF24.html#a9372266456896cd3552efe32c9353e6b">CRCPolynomial</a>&#160;</td>
          <td class="paramname"><em>polynomial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the CRC polynomial to be used to generate the CRC for both receive and transmit otherwise the default of CRC_16_IBM will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">polynomial</td><td>One of <a class="el" href="classRH__RF24.html#a9372266456896cd3552efe32c9353e6b" title="Defines the available choices for CRC Types of permitted CRC polynomials, to be passed to setCRCPolyn...">RH_RF24::CRCPolynomial</a> choices CRC_* </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if polynomial is a valid option for this radio. </dd></dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#a962a67573e1fc7156307720d1471b979">set_properties()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init()</a>.</p>

</div>
</div>
<a id="aede4988f5e9daef3b471615aae7ad720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede4988f5e9daef3b471615aae7ad720">&#9670;&nbsp;</a></span>setFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::setFrequency </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>afcPullInRange</em> = <code>0.05</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the transmitter and receiver centre frequency. Valid frequency ranges for RFM24/Si4460, Si4461, RFM25/Si4463 are: 142MHz to 175Mhz, 284MHz to 350MHz, 425MHz to 525MHz, 850MHz to 1050MHz. Valid frequency ranges for RFM26/Si4464 are: 119MHz to 960MHz. Caution: RFM modules are designed with antenna coupling components to suit a limited band of frequencies (marked underneath the module). It is possible to set frequencies in other bands, but you may only get little or no power radiated. Caution, you can only use this function to change frequency within the frequency band configured by the radio configuration header file. To use a frequency in a different band, you must recompile with the appropriate radio configuration header file. Setting a frequency in anotehr band will have unpredicatble results. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">centre</td><td>Frequency in MHz. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">afcPullInRange</td><td>Not used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the selected frequency is within a valid range for the connected radio and if setting the new frequency succeeded. </dd></dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#a962a67573e1fc7156307720d1471b979">set_properties()</a>.</p>

</div>
</div>
<a id="a43ccdf26e4ec5ac2d6fc6af15486b942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ccdf26e4ec5ac2d6fc6af15486b942">&#9670;&nbsp;</a></span>setIdleMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::setIdleMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idleMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the chip mode that will be used when the <a class="el" href="classRH__RF24.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF24 and compatible radio transce...">RH_RF24</a> driver is idle (ie not transmitting or receiving) You can use this to control the power level consumed while idle, at the cost of slower transition to tranmit or receive states </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idleMode</td><td>The chip state to use when idle. Sensible choices might be RH_RF24_DEVICE_STATE_SLEEP or RH_RF24_DEVICE_STATE_READY </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a848fae609a7a0c9f27c257763aaba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a848fae609a7a0c9f27c257763aaba9">&#9670;&nbsp;</a></span>setModeIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::setModeIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Rx or Tx changes it to Idle. If the transmitter or receiver is running, disables them. </p>

<p class="reference">References <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>, and <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a09daae373d8c5f63419be869c99f8d66">RHGenericDriver::RHModeIdle</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a7d30de3f323b945c61feac26b614a89a">readNextFragment()</a>, and <a class="el" href="classRH__RF24.html#a9aaa8c5b36eccb568c87c4c9e74e7877">send()</a>.</p>

</div>
</div>
<a id="a75f0012333f9881c111b7722632d25a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f0012333f9881c111b7722632d25a9">&#9670;&nbsp;</a></span>setModemConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::setModemConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849">ModemConfigChoice</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OBSOLETE, do not use. To get different modulation schemes, you must generate a new radio config file as described in this documentation. Select one of the predefined modem configurations. If you need a modem configuration not provided here, use <a class="el" href="classRH__RF24.html#afd00202f768b4f0f893f2fbb9e650c7b">setModemRegisters()</a> with your own <a class="el" href="structRH__RF24_1_1ModemConfig.html" title="Defines property values for a set of modem configuration registers.">ModemConfig</a>. The default after <a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init()</a> is <a class="el" href="classRH__RF24.html#a186a59163ea9e246ccd3c0d9895f1849afb07888e57822a9b934fcec3563fec99" title="GFSK Rb = 5kbs, Fd = 10kHz.">RH_RF24::GFSK_Rb5Fd10</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The configuration choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if index is a valid choice. </dd></dl>

</div>
</div>
<a id="afd00202f768b4f0f893f2fbb9e650c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd00202f768b4f0f893f2fbb9e650c7b">&#9670;&nbsp;</a></span>setModemRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::setModemRegisters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRH__RF24_1_1ModemConfig.html">ModemConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OBSOLETE, do not use. To get different modulation schemes, you must generate a new radio config file as described in this documentation. Sets all the properties required to configure the data modem in the RF24, including the data rate, bandwidths etc. You can use this to configure the modem with custom configurations if none of the canned configurations in ModemConfigChoice suit you. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>A <a class="el" href="structRH__RF24_1_1ModemConfig.html" title="Defines property values for a set of modem configuration registers.">ModemConfig</a> structure containing values for the modem configuration registers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52218f0ec1c9c8ec01b6ca771309faf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52218f0ec1c9c8ec01b6ca771309faf4">&#9670;&nbsp;</a></span>setModeRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::setModeRx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Tx or Idle, changes it to Rx. Starts the receiver in the RF24. </p>

<p class="reference">References <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>, <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a37e9e88e825d4ec7728c421e3a32e490">RHGenericDriver::RHModeRx</a>, and <a class="el" href="classRH__RF24.html#a962a67573e1fc7156307720d1471b979">set_properties()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#ad807aee44ebdc88869aca06ceefb6607">available()</a>.</p>

</div>
</div>
<a id="ad85c8e01f3b660dc612ff81890169353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85c8e01f3b660dc612ff81890169353">&#9670;&nbsp;</a></span>setModeTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::setModeTx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Rx or Idle, changes it to Rx. F Starts the transmitter in the RF24. </p>

<p class="reference">References <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>, and <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a2f830e2667843de407766fe33500713c">RHGenericDriver::RHModeTx</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a9aaa8c5b36eccb568c87c4c9e74e7877">send()</a>.</p>

</div>
</div>
<a id="ad362ade85bb04260ce35e8e1e0071a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad362ade85bb04260ce35e8e1e0071a56">&#9670;&nbsp;</a></span>setPreambleLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the length of the preamble in bytes. Caution: this should be set to the same value on all nodes in your network. Default is 4. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>Preamble length in bytes. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#a962a67573e1fc7156307720d1471b979">set_properties()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init()</a>.</p>

</div>
</div>
<a id="a9eaa19e721fe511ac04b08e9e3a7e723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaa19e721fe511ac04b08e9e3a7e723">&#9670;&nbsp;</a></span>setSyncWords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::setSyncWords </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>syncWords</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sync words for transmit and receive Caution: SyncWords should be set to the same value on all nodes in your network. Nodes with different SyncWords set will never receive each others messages, so different SyncWords can be used to isolate different networks from each other. Default is { 0x2d, 0xd4 }. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">syncWords</td><td>Array of sync words, 1 to 4 octets long. NULL if no sync words to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of sync words to set, 1 to 4. 0 if no sync words to be used. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#a962a67573e1fc7156307720d1471b979">set_properties()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init()</a>.</p>

</div>
</div>
<a id="a2078de5a7a5821a673fcf7ab95ab8575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2078de5a7a5821a673fcf7ab95ab8575">&#9670;&nbsp;</a></span>setTxPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::setTxPower </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>power</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the transmitter power output level register PA_PWR_LVL The power argument to this function has a non-linear correlation with the actual RF power output. See the transmitter power table above for some examples. Also the Si446x Data Sheet section 5.4.2 may be helpful. Be a good neighbour and set the lowest power level you need. Caution: legal power limits may apply in certain countries. After <a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init()</a>, the power will be set to 0x10. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>Transmitter power level. For RFM24/Si4460, valid values are 0x00 to 0x4f. For others, 0x00 to 0x7f </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classRH__RF24.html#a962a67573e1fc7156307720d1471b979">set_properties()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a2cb53e42f79e769497ae564a8d74230e">init()</a>.</p>

</div>
</div>
<a id="a09177ddfb09bf6ca41b94503cbee9fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09177ddfb09bf6ca41b94503cbee9fb7">&#9670;&nbsp;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the radio into low-power sleep mode. If successful, the transport will stay in sleep mode until woken by changing mode it idle, transmit or receive (eg by calling <a class="el" href="classRH__RF24.html#a9aaa8c5b36eccb568c87c4c9e74e7877">send()</a>, <a class="el" href="classRH__RF24.html#a9937ab8c31b887a2d47c9e7fd2c7370e">recv()</a>, <a class="el" href="classRH__RF24.html#ad807aee44ebdc88869aca06ceefb6607">available()</a> etc) Caution: there is a time penalty as the radio takes a finte time to wake from sleep mode. </p><dl class="section return"><dt>Returns</dt><dd>true if sleep mode was successfully entered. </dd></dl>

<p>Reimplemented from <a class="el" href="classRHGenericDriver.html#a97050555cbf46ad723ad9c45d7f76a55">RHGenericDriver</a>.</p>

<p class="reference">References <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRH__RF24.html#ab5a2b39cc3a6350addb97327b6f8af33">command()</a>, and <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a39cb96e8e2d40d5a4137f99c9d98d01b">RHGenericDriver::RHModeSleep</a>.</p>

</div>
</div>
<a id="a183d6f3dabcf5a1e8a63ba5802621d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183d6f3dabcf5a1e8a63ba5802621d87">&#9670;&nbsp;</a></span>validateRxBuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF24::validateRxBuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks the contents of the RX buffer. If it contans a valid message adressed to this node sets _rxBufValid. </p>

<p class="reference">References <a class="el" href="classRHGenericDriver.html#a2d94c93203714ed3dd9a7434101683e9">RHGenericDriver::_promiscuous</a>, <a class="el" href="classRHGenericDriver.html#abf09ee8b0cc1bf2b64dc0d963895ff71">RHGenericDriver::_rxGood</a>, <a class="el" href="classRHGenericDriver.html#a5fd0c3bbc3cfe199924a9e1cb909f5fd">RHGenericDriver::_rxHeaderFlags</a>, <a class="el" href="classRHGenericDriver.html#a7283cfec4e7c1ecf074307534592fd8f">RHGenericDriver::_rxHeaderFrom</a>, <a class="el" href="classRHGenericDriver.html#a3155557c35198acdde0ecdf58a201b19">RHGenericDriver::_rxHeaderId</a>, <a class="el" href="classRHGenericDriver.html#abff3740bc072a2d435194a7860b2bfe3">RHGenericDriver::_rxHeaderTo</a>, and <a class="el" href="classRHGenericDriver.html#a6d2e9824e29c9d5e9ad28682e53ea974">RHGenericDriver::_thisAddress</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#ace446bd70542adeedf7f7403212e809c">handleInterrupt()</a>.</p>

</div>
</div>
<a id="afd54aecdd3cff38aca2a912c200e3fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd54aecdd3cff38aca2a912c200e3fe7">&#9670;&nbsp;</a></span>writeTxFifo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF24::writeTxFifo </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads data into the chips TX FIFO </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Array of data bytes to be loaded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes in data to be loaded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

<p class="reference">References <a class="el" href="classRHSPIDriver.html#ab63525878860cc6ab6c4a994ce704735">RHSPIDriver::_slaveSelectPin</a>, <a class="el" href="classRHSPIDriver.html#ad9ee8d997815ec209d3208967107ffb1">RHSPIDriver::_spi</a>, <a class="el" href="classRHGenericSPI.html#ae5524b6770c879a44b2452018ac6331e">RHGenericSPI::beginTransaction()</a>, <a class="el" href="classRHGenericSPI.html#a8c19b76e39fdb611160f673b5b9da0ee">RHGenericSPI::endTransaction()</a>, and <a class="el" href="classRHGenericSPI.html#a14bc6f8954d9d68c0a56319444ffdd24">RHGenericSPI::transfer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classRH__RF24.html#a24d9f5aa2574d6a551d4e2aea956353a">sendNextFragment()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="RH__RF24_8h_source.html">RH_RF24.h</a></li>
<li>RH_RF24.cpp</li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassRH__RF24_html"><div class="ttname"><a href="classRH__RF24.html">RH_RF24</a></div><div class="ttdoc">Driver to send and receive unaddressed, unreliable datagrams via an RF24 and compatible radio transce...</div><div class="ttdef"><b>Definition:</b> RH_RF24.h:685</div></div>
<div class="ttc" id="aclassRHGenericDriver_html_aa3e349acc48e935bf30111d388458e7b"><div class="ttname"><a href="classRHGenericDriver.html#aa3e349acc48e935bf30111d388458e7b">RHGenericDriver::lastRssi</a></div><div class="ttdeci">virtual int16_t lastRssi()</div><div class="ttdef"><b>Definition:</b> RHGenericDriver.cpp:154</div></div>
<div class="ttc" id="aclassRH__RF22_html_ac60d2676f1177e509e7d31df515dfb11"><div class="ttname"><a href="classRH__RF22.html#ac60d2676f1177e509e7d31df515dfb11">RH_RF22::setTxPower</a></div><div class="ttdeci">void setTxPower(uint8_t power)</div><div class="ttdef"><b>Definition:</b> RH_RF22.cpp:493</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
