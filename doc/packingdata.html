<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioHead: $title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RadioHead
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">RadioHead Packet Radio library for embedded microprocessors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="contents">
<div class="textblock"><dl class="section user"><dt>Passing Sensor Data Between RadioHead nodes</dt><dd></dd></dl>
<p>People often ask about how to send data (such as numbers, sensor readings etc) from one RadioHead node to another. Although this issue is not specific to RadioHead, and more properly lies in the area of programming for networks, we will try to give some guidance here.</p>
<p>One reason for the uncertainty and confusion in this area, especially amongst beginners, is that there is no <em>best</em> way to do it. The best solution for your project may depend on the range of processors and data that you have to deal with. Also, it gets more difficult if you need to send several numbers in one packet, and/or deal with floating point numbers and/or different types of processors.</p>
<p>The principal cause of difficulty is that different microprocessors of the kind that run RadioHead may have different ways of representing binary data such as integers. Some processors are little-endian and some are big-endian in the way they represent multi-byte integers (<a href="https://en.wikipedia.org/wiki/Endianness">https://en.wikipedia.org/wiki/Endianness</a>). And different processors and maths libraries may represent floating point numbers in radically different ways: (<a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">https://en.wikipedia.org/wiki/Floating-point_arithmetic</a>)</p>
<p>All the RadioHead examples show how to send and receive simple ASCII strings, and if thats all you want, refer to the examples folder in your RadioHead distribution. But your needs may be more complicated than that.</p>
<p>The essence of all engineering is compromise so it will be up to you to decide whats best for your particular needs. The main choices are:</p><ul>
<li>Raw Binary</li>
<li>Network Order Binary</li>
<li>ASCII</li>
</ul>
<dl class="section user"><dt>Raw Binary</dt><dd></dd></dl>
<p>With this technique you just pack the raw binary numbers into the packet:</p>
<div class="fragment"><div class="line"><span class="comment">// Sending a single 16 bit unsigned integer</span></div>
<div class="line"><span class="comment">// in the transmitter:</span></div>
<div class="line">...</div>
<div class="line">uint16_t data = getsomevalue();</div>
<div class="line"><span class="keywordflow">if</span> (!driver.send((uint8_t*)&amp;data, <span class="keyword">sizeof</span>(data)))</div>
<div class="line">{</div>
<div class="line">    ...</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// and in the receiver:</span></div>
<div class="line">...</div>
<div class="line">uint16_t data;</div>
<div class="line">uint8_t datalen = <span class="keyword">sizeof</span>(data);</div>
<div class="line"><span class="keywordflow">if</span> (   driver.recv((uint8_t*)&amp;data, &amp;datalen)</div>
<div class="line">    &amp;&amp; datalen == <span class="keyword">sizeof</span>(data))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Have the data, so do something with it</span></div>
<div class="line">    uint16_t xyz = data;</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>If you need to send more than one number at a time, its best to pack them into a structure</p>
<div class="fragment"><div class="line"><span class="comment">// Sending several 16 bit unsigned integers in a structure</span></div>
<div class="line"><span class="comment">// in a common header for your project:</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    uint16_t   dataitem1;</div>
<div class="line">    uint16_t   dataitem2;</div>
<div class="line">} MyDataStruct;</div>
<div class="line">...</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// In the transmitter</span></div>
<div class="line">...</div>
<div class="line">MyDataStruct data;</div>
<div class="line">data.dataitem1 = getsomevalue();</div>
<div class="line">data.dataitem2 = getsomeothervalue();</div>
<div class="line"><span class="keywordflow">if</span> (!driver.send((uint8_t*)&amp;data, <span class="keyword">sizeof</span>(data)))</div>
<div class="line">{</div>
<div class="line">    ...</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// in the receiver</span></div>
<div class="line">MyDataStruct data;</div>
<div class="line">uint8_t datalen = <span class="keyword">sizeof</span>(data);</div>
<div class="line"><span class="keywordflow">if</span> (   driver.recv((uint8_t*)&amp;data, &amp;datalen)</div>
<div class="line">    &amp;&amp; datalen == <span class="keyword">sizeof</span>(data))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Have the data, so do something with it</span></div>
<div class="line">    uint16_t pqr = data.dataitem1;</div>
<div class="line">    uint16_t xyz = data.dataitem2;</div>
<div class="line">    ....</div>
</div><!-- fragment --><p>The disadvantage with this simple technique becomes apparent if your transmitter and receiver have different endianness: the integers you receive will not be the same as the ones you sent (actually they are, but with the internal bytes swapped around, so they probably wont make sense to you). Endianness is not a problem if <em>every</em> data item you send is a just single byte (uint8_t or int8_t or char), or if the transmitter and receiver have the same endianness.</p>
<p>So you should only adopt this technique if:</p><ul>
<li>You only send data items of a single byte each, or</li>
<li>You are absolutely sure (now and forever into the future) that you will only ever use the same processor endianness in the transmitter and receiver.</li>
</ul>
<dl class="section user"><dt>Network Order Binary</dt><dd></dd></dl>
<p>One solution to the issue of endianness in your processors is to always convert your data from the processor's native byte order to 'network byte order' before transmission and then convert it back to the receiver's native byte order on reception. You do this with the htons (host to network short) macro and friends. These functions may be a no-op on big-endian processors.</p>
<p>With this technique you convert every multi-byte number to and from network byte order (note that in most Arduino processors an integer is in fact a short, and is the same as int16_t. We prefer to use types that explicitly specify their size so we can be sure of applying the right conversions):</p>
<div class="fragment"><div class="line"><span class="comment">// Sending a single 16 bit unsigned integer</span></div>
<div class="line"><span class="comment">// in the transmitter:</span></div>
<div class="line">...</div>
<div class="line">uint16_t data = htons(getsomevalue());</div>
<div class="line"><span class="keywordflow">if</span> (!driver.send((uint8_t*)&amp;data, <span class="keyword">sizeof</span>(data)))</div>
<div class="line">{</div>
<div class="line">    ...</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// and in the receiver:</span></div>
<div class="line">...</div>
<div class="line">uint16_t data;</div>
<div class="line">uint8_t datalen = <span class="keyword">sizeof</span>(data);</div>
<div class="line"><span class="keywordflow">if</span> (   driver.recv((uint8_t*)&amp;data, &amp;datalen)</div>
<div class="line">    &amp;&amp; datalen == <span class="keyword">sizeof</span>(data))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Have the data, so do something with it</span></div>
<div class="line">    uint16_t xyz = ntohs(data);</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>If you need to send more than one number at a time, its best to pack them into a structure</p>
<div class="fragment"><div class="line"><span class="comment">// Sending several 16 bit unsigned integers in a structure</span></div>
<div class="line"><span class="comment">// in a common header for your project:</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    uint16_t   dataitem1;</div>
<div class="line">    uint16_t   dataitem2;</div>
<div class="line">} MyDataStruct;</div>
<div class="line">...</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// In the transmitter</span></div>
<div class="line">...</div>
<div class="line">MyDataStruct data;</div>
<div class="line">data.dataitem1 = htons(getsomevalue());</div>
<div class="line">data.dataitem2 = htons(getsomeothervalue());</div>
<div class="line"><span class="keywordflow">if</span> (!driver.send((uint8_t*)&amp;data, <span class="keyword">sizeof</span>(data)))</div>
<div class="line">{</div>
<div class="line">    ...</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// in the receiver</span></div>
<div class="line">MyDataStruct data;</div>
<div class="line">uint8_t datalen = <span class="keyword">sizeof</span>(data);</div>
<div class="line"><span class="keywordflow">if</span> (   driver.recv((uint8_t*)&amp;data, &amp;datalen)</div>
<div class="line">    &amp;&amp; datalen == <span class="keyword">sizeof</span>(data))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Have the data, so do something with it</span></div>
<div class="line">    uint16_t pqr = ntohs(data.dataitem1);</div>
<div class="line">    uint16_t xyz = ntohs(data.dataitem2);</div>
<div class="line">    ....</div>
</div><!-- fragment --><p>This technique is quite general for integers but may not work if you want to send floating point number between transmitters and receivers that have different floating point number representations.</p>
<dl class="section user"><dt>ASCII</dt><dd></dd></dl>
<p>In this technique, you transmit the printable ASCII equivalent of each floating point and then convert it back to a float in the receiver:</p>
<div class="fragment"><div class="line"><span class="comment">// In the transmitter</span></div>
<div class="line">...</div>
<div class="line">float data = getsomevalue();</div>
<div class="line">uint8_t buf[15]; <span class="comment">// Bigger than the biggest possible ASCII</span></div>
<div class="line">snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;%f&quot;</span>, data);</div>
<div class="line"><span class="keywordflow">if</span> (!driver.send(buf, strlen(buf) + 1)) <span class="comment">// Include the trailing NUL</span></div>
<div class="line">{</div>
<div class="line">    ...</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// In the receiver</span></div>
<div class="line">...</div>
<div class="line">float data;</div>
<div class="line">uint8_t buf[15]; <span class="comment">// Bigger than the biggest possible ASCII</span></div>
<div class="line">uint8_t buflen = <span class="keyword">sizeof</span>(buf);</div>
<div class="line"><span class="keywordflow">if</span> (driver.recv(buf, &amp;buflen))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Have the data, so do something with it</span></div>
<div class="line">    <span class="keywordtype">float</span> data = atof(buf); <span class="comment">// String to float</span></div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section user"><dt>Conclusion:</dt><dd></dd></dl>
<ul>
<li>This is just a basic introduction to the issues. You may need to extend your study into related C/C++ programming techniques.</li>
<li>You can extend these ideas to signed 16 bit (int16_t) and 32 bit (uint32_t, int32_t) numbers.</li>
<li>Things can be simple or complicated depending on the needs of your project.</li>
<li>We are not going to write your code for you: its up to you to take these examples and explanations and extend them to suit your needs. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
